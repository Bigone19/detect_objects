# -*- coding: utf-8 -*-

import cv2
import time
import numpy as np
import os
from PIL import Image, ImageDraw, ImageFont
from matplotlib import pyplot as plt

# Merge the two image.
def img_enlarge(img):
    # src = cv2.imread('background.png')
    h, w = img.shape[:2]
    enlarge_img = cv2.resize(img, (0, 0), fx=1.3, fy=1.3, interpolation=cv2.INTER_CUBIC)
    # cv2.imshow('img', enlarge_img)
    return enlarge_img

cap = cv2.VideoCapture(1)
cap.set(3, 1280)
cap.set(4, 720)
#cap.set(5, 15)

# define the minimal ROI resolution.
AREA = 20000

# golden gate bridge's classifier
cascade_1 = cv2.CascadeClassifier('classifier/cascade_01.xml') # bridge tower
cascade_2 = cv2.CascadeClassifier('classifier/cascade_02.xml') # suspension cable
cascade_3 = cv2.CascadeClassifier('classifier/cascade_03.xml') # the main classifier

# tai mahal's classifier
cascade_4 = cv2.CascadeClassifier('classifier/cascade_04.xml') # the main classifier
cascade_5 = cv2.CascadeClassifier('classifier/cascade_05.xml') # spherical dome
cascade_6 = cv2.CascadeClassifier('classifier/cascade_06.xml') # minaret
cascade_7 = cv2.CascadeClassifier('classifier/cascade_07.xml') # arch

cascade_8 = cv2.CascadeClassifier('classifier/cascade_08.xml') # Shanxi Cave Dwellings
cascade_9 = cv2.CascadeClassifier('classifier/cascade_09.xml') # arch door
cascade_10 = cv2.CascadeClassifier('classifier/cascade_10.xml') # timber door
cascade_11 = cv2.CascadeClassifier('classifier/cascade_11.xml') # Carved wooden Windows
cascade_12 = cv2.CascadeClassifier('classifier/cascade_12.xml') # roof ornament


# init font
font = cv2.FONT_HERSHEY_SIMPLEX
font2 = ImageFont.truetype("font/simhei.ttf", 12, encoding="utf-8")

while True:
    ret, frame = cap.read()
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # define the golden gate bridge cascade classifier.
    objs_3 = cascade_3.detectMultiScale(gray, 1.3, 17)
    # define the tai mahal cascade classifier.
    objs_4 = cascade_4.detectMultiScale(gray, 1.3, 17)
    objs_8 = cascade_8.detectMultiScale(gray, 1.3, 17)
    # find the main object.

    if len(objs_3) > 0:
        for (x, y, w, h) in objs_3:
            if w * h > AREA:
                # size_obj_3 = w * h
                # crop_img = frame[x: x+w, y: y+h]
                # cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 200, 0), 2)
                # cv2.putText(frame, "This is the Golden Gate Brdige", (x, y + 50), font, 0.7, (255, 0, 255), 3, cv2.LINE_AA)
                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                frame_pil = Image.fromarray(frame)
                draw = ImageDraw.Draw(frame_pil)
                ImageDraw.Draw(frame_pil).text((0, 0), "The Golden Gate Bridge was opened in 1937.\n Its lenghth is about 2.7 kilometers. It is one of the largest single-hole suspension bridges\n in the world and is considered a symbol of San Francisco. The Golden Gate Bridge is also\n a pioneering undertaking in bridge architecture. It has only two pillars, instead of\n using the pier to support the bridge, it uses the huge pulling force generated by the\n curved slings on both sides of the bridge to lift the heavy bridge.\n\n金门大桥是1937年开通的，全长约2.7千米,是世界上最大的单孔吊桥之一，被视为旧金山的象征。\n金门桥在桥梁建筑学上也是一个创举。它只有两大支柱，因此它不是利用桥墩支撑桥身，\n而是利用桥两侧的弧形吊带产生的巨大拉力，\n把沉重的桥身高高吊起。", (0, 0, 0), font2)
                frame = cv2.cvtColor(np.array(frame_pil), cv2.COLOR_RGB2BGR)
                # detect the sub-objects.
                roi_gray_objs = gray[y: y+h, x: x+w]
                roi_objs = frame[y: y+h, x: x+w]

                # crop_3 = frame[y: y+h, x: x+w]
                # cv2.imwrite("roi/the_golden_gate_bridge.png", crop_3)             

                # bridge tower cascade classifier.
                objs_1 = cascade_1.detectMultiScale(roi_gray_objs, 1.3, 15)
                # suspension cable cascade classifier.
                objs_2 = cascade_2.detectMultiScale(roi_gray_objs, 1.3, 15)
                '''
                    find the sub-objects:
                      the bridge tower
                      the suspension cable
                '''
                for (bx, by, bw, bh) in objs_1:
                    crop_1 = frame[by: by+bh, bx: bx+bw]
                    cv2.rectangle(roi_objs, (bx, by), (bx + bw, by + bh), (100, 255, 100), 2)
                    cv2.putText(roi_objs, "bridge tower", (bx , by), font, 0.5, (255, 0, 255), 1, cv2.LINE_AA)
                    enl1 = img_enlarge(crop_1)
                    # cv2.imshow('bridge tower', enl1)
                    break

                for (sx, sy, sw, sh) in objs_2:
                    crop_2 = roi_objs[sy: sy+sh, sx: sx+sw]
                    cv2.rectangle(roi_objs, (sx, sy), (sx + sw, sy + sh), (255, 0, 0), 2)
                    cv2.putText(roi_objs, "suspension cable", (sx , sy), font, 0.5, (255, 0, 255), 1, cv2.LINE_AA)
                    enl2 = img_enlarge(crop_2)
                    # cv2.imshow('suspension cable', enl2)
                    break                    

            else:
                break

    if len(objs_8) > 0:
        for x, y, w, h in objs_8:
            if w * h > AREA:
                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                frame_pil = Image.fromarray(frame)
                draw = ImageDraw.Draw(frame_pil)
                ImageDraw.Draw(frame_pil).text((0, 0), "The cave dwelling is an ancient form of residence for the inhabitants of\n the Loess Plateau in northwestern China. In the Shaanxi-Gansu-Ningxia region, the loess \nlayer is very thick, and some are as thick as tens of kilometers. The Chinese people \ncreatively use the favorable terrain of the plateau to create a cave-dwelling building\n called a green building. Cave dwellings generally have cliff-type cave dwellings, \nsinking cave dwellings, and independent cave dwellings. The cave dwelling is a product of\n the Loess Plateau, a symbol of the people of northern Shaanxi, which deposited the deep \nculture of the ancient Yellow Land.\n\n窑洞是中国西北黄土高原上居民的古老居住形式。在中国陕甘\n宁地区，黄土层非常厚，有的厚达几十公里，中国人民创造性地利用高原有利的地形，凿洞而居，创造了被称\n为绿色建筑的窑洞建筑。窑洞一般有靠崖式窑洞，下沉式窑洞，独立式窑洞等。窑洞是黄土高原的产物，陕\n北人民的象征，它沉积了古老的黄土地深层文化。", (0, 0, 0), font2)
                frame = cv2.cvtColor(np.array(frame_pil), cv2.COLOR_RGB2BGR)
                # detect the sub-objects.
                roi_gray_objs = gray[y: y+h, x: x+w]
                roi_objs = frame[y: y+h, x: x+w]
                
                # 9 > 10 & 9 > 11 & 10 == 11
                objs_9 = cascade_9.detectMultiScale(roi_gray_objs, 1.3, 5)
                objs_10 = cascade_10.detectMultiScale(roi_gray_objs, 1.3, 5)
                objs_11 = cascade_11.detectMultiScale(roi_gray_objs, 1.3, 5)
                objs_12 = cascade_12.detectMultiScale(roi_gray_objs, 1.3, 5)

                # a t c
                for ax, ay, aw, ah in objs_9:
                    cv2.rectangle(roi_objs, (ax, ay), (ax + aw, ay + ah), (100, 255, 100), 2)
                    cv2.putText(roi_objs, "arch door", (ax , ay), font, 0.5, (255, 0, 255), 1, cv2.LINE_AA)
                    sub_roi_gray = roi_gray_objs[ay: ay+ah, ax: ax+aw]
                    sub_roi = roi_objs[ay: ay+ah, ax: ax+aw]

                    for tx, ty, tw, th in objs_10:
                        cv2.rectangle(sub_roi, (tx, ty), (tx + tw, ty + th), (0, 255, 100), 2)
                        cv2.putText(sub_roi, "timber door", (tx , ty), font, 0.5, (255, 0, 25), 1, cv2.LINE_AA)
                        break
                    for cx, cy, cw, ch in objs_10:
                        cv2.rectangle(sub_roi, (cx, cy), (cx + cw, cy + ch), (100, 25, 100), 2)
                        cv2.putText(sub_roi, "timber door", (cx , cy), font, 0.5, (255, 200, 25), 1, cv2.LINE_AA)
                        break
                    break
                  
                for rx, ry, rw, rh in objs_12:
                    cv2.rectangle(roi_objs, (rx, ry), (rx + rw, ry + rh), (100, 25, 200), 2)
                    cv2.putText(roi_objs, "roof ornament", (rx , ry), font, 0.5, (2, 100, 255), 1, cv2.LINE_AA)
                    break

    if len(objs_4) > 0:
        for (x, y, w, h) in objs_4:
            if w * h > AREA:
                # cv2.rectangle(frame, (x, y), (x + w, y + h), (25, 200, 150), 2)
                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                frame_pil = Image.fromarray(frame)
                draw = ImageDraw.Draw(frame_pil)
                ImageDraw.Draw(frame_pil).text((0, 0), "The Taj Mahal is a rectangular mausoleum,\n 576 meters long and 293 meters wide,\n with a total area of 170,000 square meters.\n It was surrounded by a red sandstone wall.\n The central part is the mausoleum. Mosque and defense hall are built on both sides of the mausoleum.\n The two buildings are symmetrical and balanced, which correspond to each other.\n Each of the four sides of the mausoleum has a steeple,\n up to 40 meters high, with 50 stairs inside, which are designed for Muslim imams to climb up.\n The entrance to the mausoleum is connected by a wide,\n straight passage of red stone, symmetrical on the left and right,\n and neatly laid out.\n On either side of the walkway was a sidewalk with a fountain in the middle.\n\n泰姬陵整个陵园是一个长方形，长576米，宽293米，总面积为17万平方米。\n四周被一道红砂石墙围绕。正中央是陵寝，在陵寝东西两侧各建有清真寺和答辩厅这两座式样相同的建筑\n，两座建筑对称均衡，左右呼应。\n陵的四方各有一座尖塔，高达40米，内有50层阶梯，是专供穆斯林阿訇拾级登高而上的。\n大门与陵墓由一条宽阔笔直的用红石铺成的甬道相连接，左右两边对称，布局工整。\n在甬道两边是人行道，人行道中间修建了一个“十”字形喷泉水池。", (0, 0, 0), font2)
                frame = cv2.cvtColor(np.array(frame_pil), cv2.COLOR_RGB2BGR)
                # detect the sub-objects.
                roi_gray_objs = gray[y: y+h, x: x+w]
                roi_objs = frame[y: y+h, x: x+w]
                
                # spherical dome cascade classifier
                objs_5 = cascade_5.detectMultiScale(gray, 1.3, 15)
                # minaret cascade classifier
                objs_6 = cascade_6.detectMultiScale(gray, 1.3, 15)
                # arch cascade classifier
                objs_7 = cascade_7.detectMultiScale(gray, 1.3, 15)

                for (sx, sy, sw, sh) in objs_5:
                    cv2.rectangle(roi_objs, (sx, sy), (sx + sw, sy + sh), (255, 0, 0), 2)
                    cv2.putText(roi_objs, "spherical dome", (sx , sy), font, 0.5, (255, 0, 255), 1, cv2.LINE_AA)
                    break
                
                for (mx, my, mw, mh) in objs_6:
                    cv2.rectangle(roi_objs, (mx, my), (mx + mw, my + mh), (0, 255, 0), 2)
                    cv2.putText(roi_objs, "minaret", (mx , my), font, 0.5, (0, 0, 255), 1, cv2.LINE_AA)
                    break

                for (ax, ay, aw, ah) in objs_7:
                    cv2.rectangle(roi_objs, (ax, ay), (ax + aw, ay + ah), (0, 255, 0), 2)
                    cv2.putText(roi_objs, "arch", (ax , ay), font, 0.5, (200, 100, 255), 1, cv2.LINE_AA)
                    break
                
            else:
                break


    res_enlarge = img_enlarge(frame)
    cv2.imshow('res', res_enlarge)
    # print(cv2.CAP_PROP_FPS)
    
    k = cv2.waitKey(30) & 0xFF
    if k == 27:
        break

cap.release()
cv2.destroyAllWindows()




